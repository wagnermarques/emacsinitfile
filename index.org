#+Title: W E L C O M E    T O    E M A C S I N I T F I L E


This emacs is for support development tasks e some another daily tasks

keep in mind that I've been use fedora distribution

To use this emacs configuracion you should tell the path os
development tools in global_variables_setup.el

And start your emacs with a acommand like:  emacs -q l emacsinitfile_cloned_dir/init2.el

The [[file:install-dev-packages.sh]] contains the packages that will be
installed

* some of utils key bindins (shortcuts)
  This shortcut keys is defined in [[file:fzl_keys.el]]

  Esc+s -> open shell-mode. A bash terminal inside emacs
  C-c s -> opens ansi-term 
  Esc+a -> open org agenda list
  Esc+t -> open todo list


* Programming tools considered
   https://nodejs.org/en/
   http://yeoman.io/
   https://gruntjs.com/
   https://dojo.io/tutorials/   


* forms
** EMACS CONFIGURATION FORM  
  #+BEGIN_SRC emacs-lisp
    (defun show-properties-form()
        "show properties form in or without fzlbpms presence"
        (setq debug-on-error t)
        (forms-find-file './form-control-for-properties.el'))
    (show-properties-form)
  #+END_SRC  

  #+RESULTS:
  : show-properties-form

** forms instructions
*** general instructions
    "-*- forms -*-" (in the very begginer of the file active forms-mode)
*** records navigation 
    ;; [next]	  forms-next-record
    ;; [prior]	  forms-prev-record
    ;; [begin]	  forms-first-record
    ;; [end]	  forms-last-record
    ;; [S-TAB]	  forms-prev-field
    ;; [backtab]	  forms-prev-field

*** Edit mode commands:
    ;;
    ;; TAB		 forms-next-field
    ;; \C-c TAB	 forms-next-field
    ;; \C-c <	 forms-first-record
    ;; \C-c >	 forms-last-record
    ;; \C-c ?	 describe-mode
    ;; \C-c \C-k	 forms-delete-record
    ;; \C-c \C-q	 forms-toggle-read-only
    ;; \C-c \C-o	 forms-insert-record
    ;; \C-c \C-l	 forms-jump-record
    ;; \C-c \C-n	 forms-next-record
    ;; \C-c \C-p	 forms-prev-record
    ;; \C-c \C-r	 forms-search-backward
    ;; \C-c \C-s	 forms-search-forward
    ;; \C-c \C-x	 forms-exit

    

* urls
  http://localhost:8081/#browse/welcome
  file:///home/administrador/progsativos/fzlbpms/integrated/servers/Runtime_ESBSE/docs/cxf-api/index.html
  file:///home/administrador/progsativos/fzlbpms/integrated/servers/Runtime_ESBSE/docs/cxf-api/index-all.html


* Integrated
** talend
  http://talendforge.org/forum
  http://cxf.apache.org/
  http://camel.apache.org/
  http://karaf.apache.org/

*** Service Locator

***  Service Activity Monitoring (SAM) 
     log / monitor service calls done with the Apache CXF Framework

** Karaf
   
   http://karaf.apache.org/index.html
   
** mutt
   j: move to next unread email
   k move to previous unread email
   SPACE read current email
   http://www.ucolick.org/%7Elharden/muttchart.html
* tutorials
** execute code within org-mode
   just C-c C-c to evaluate the code
     #+BEGIN_SRC emacs-lisp
       (+ 10 2 3 4)
     #+END_SRC  

     #+RESULTS:
=19
=   




* EMACSINITFILE TODO_LISTS
** configure web-mode
   http://web-mode.org/
   config-web-mode.el








** define enviroment variable in one properties file
   (defun define_enviroment_variables_from_file()
   

* FZLBPMS TODO_LIST
** TODO <2015-11-15 Dom> config enviroment
*** TODO <2015-11-15 Dom> when enviroment variable FZL_HOME is difined without "/" at its end, the directory needs helps, whent there is "/" there ara no problmes
** eclipse
*** TODO <2015-11-14 Sáb> prepare eclipse modelling
**** TODO <2015-11-14 Sáb> install papyrus acceleo m2eclipse
**** TODO <2015-11-14 Sáb> emacs
*** TODO <2015-11-14 Sáb> prepare eclipse reporting 

* ANOTS
** exoplataform
   Primeiro portal a oferecer suporte total (consumer and provider) -
   Java Portlet 2.0 API (JSR 286) and Web Service Remote Portlet 2.0
   (WSRP).[1]

*** DONE The Portlet 2.0 API introduces many new features such as:
    Inter-Portlet Communication (IPC) which allows the sending of events and parameters to other portlets (not necessary in the same WAR)
    Portlet Filters to mimic the servlet filters behavior
    Public Parameters to share render parameters with all portlets during the render phase
    Advanced Cache Behavior as this part was very limited in JSR 168
    A new serverResource() method to better handle image insertion (instead of going through a servlet)
    An URL Listener mechanism to trigger a handler when an URL is called

*** Inter-Portlet Communication explained*
    let's take a look at what the process is in the context of the JSR 168
  portlet request.
  In JSR 168, a request was split in two phases:

  processAction() : which targets a single portlet to change the state of a business object like a JavaBean
  render() : which is called on every portlet of the page and which is responsible for rendering the HTML fragment

From this, we can see that JSR 168 only defines user interface
 rendering in the context of a single portlet.
 It _does not define any standard way regarding the communication between portlets_ that is a key point to build composite applications.

 That said, 
 developers have often taken advantage of the fact that 
 _you can share a JavaBean object between multiple portlets using the
 HTTP session._

 However, this is restrictive since this sort of session-based sharing is limited to the portlets that are deployed in the same WAR.
 In a real life scenario, portlets may come from different providers
and be bundled in different WARs. 
Still we would like to provide some interaction between portlets,
 allowing the portal user to create powerful composite applications. 
For example, you may have built an address book portlet that displays
 the details of a user including their address, and want to update a
 third-party portlet that uses Google Maps web services to show the
 address location on a map.

That is why the JSR 286, as shown in the next sequence diagram (taken
from the specification text itself), has introduced a processEvent()
phase, which will trigger events at the end of the processAction()
phase:

It is important to see that a 2 phase request was mandatory as the
rendered HTML fragments could be dependent on a modified JavaBean
object and hence the processAction() method should occur before any
render() call.


*** exo CMS
    eXo Java Content Repository (eXo JCR) is our implementation of JSR
    170

*** PICO Container
   Cada componentes desenvolvido no exo é um plugin e amarrado com IoC
   através do PICO Container (um container para injeção de
   dependencia)[1]
*** REF:
   [1] https://www.infoq.com/articles/exo-platform





